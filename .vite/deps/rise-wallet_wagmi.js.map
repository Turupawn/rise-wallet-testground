{
  "version": 3,
  "sources": ["../../node_modules/rise-wallet/src/wagmi/Actions.ts", "../../node_modules/rise-wallet/src/viem/AccountActions.ts", "../../node_modules/rise-wallet/src/viem/WalletActions.ts", "../../node_modules/rise-wallet/src/wagmi/internal/core.ts", "../../node_modules/rise-wallet/src/wagmi/Connector.ts", "../../node_modules/rise-wallet/src/wagmi/Hooks.ts", "../../node_modules/rise-wallet/src/wagmi/internal/react.ts", "../../node_modules/rise-wallet/src/wagmi/internal/utils.ts", "../../node_modules/rise-wallet/src/wagmi/internal/query.ts", "../../node_modules/rise-wallet/src/wagmi/Query.ts"],
  "sourcesContent": ["export {\n  addFunds,\n  connect,\n  disconnect,\n  getAdmins,\n  getAssets,\n  getPermissions,\n  grantAdmin,\n  grantPermissions,\n  revokeAdmin,\n  revokePermissions,\n  upgradeAccount,\n} from './internal/core.js'\n", "/**\n * Porto Account Actions.\n */\n\nimport type { Client } from 'viem'\nimport * as z from 'zod/mini'\nimport * as RpcSchema from '../core/RpcSchema.js'\nimport type * as RpcSchema_viem from './RpcSchema.js'\n\nexport async function verifyEmail(\n  client: Client,\n  parameters: verifyEmail.Parameters,\n): Promise<verifyEmail.ReturnType> {\n  const method = 'account_verifyEmail' as const\n  type Method = typeof method\n  const response = await client.request<\n    Extract<RpcSchema_viem.Wallet[number], { Method: Method }>\n  >({\n    method,\n    params: [z.encode(RpcSchema.account_verifyEmail.Parameters, parameters)],\n  })\n\n  return z.decode(RpcSchema.account_verifyEmail.Response, response)\n}\n\nexport declare namespace verifyEmail {\n  type Parameters = RpcSchema.account_verifyEmail.Parameters\n\n  type ReturnType = RpcSchema.account_verifyEmail.Response\n}\n", "/**\n * Porto Wallet Actions.\n *\n * Note: These Actions will eventually be upstreamed into `viem` once an\n * API is solidified & stable.\n */\n\nimport * as Hex from 'ox/Hex'\nimport {\n  type Call,\n  type Calls,\n  type Chain,\n  type Client,\n  encodeFunctionData,\n  type Narrow,\n  type PrivateKeyAccount,\n  type Transport,\n  type ValueOf,\n  type WalletActions as viem_WalletActions,\n} from 'viem'\nimport {\n  getAddresses,\n  getCallsStatus,\n  getCapabilities,\n  getChainId,\n  requestAddresses,\n  sendCalls,\n  showCallsStatus,\n  signMessage,\n  signTypedData,\n  waitForCallsStatus,\n  writeContract,\n} from 'viem/actions'\nimport * as z from 'zod/mini'\nimport * as RpcSchema from '../core/RpcSchema.js'\nimport * as Account from './Account.js'\nimport type { GetAccountParameter } from './internal/utils.js'\nimport type * as RpcSchema_viem from './RpcSchema.js'\n\nconst supportedWalletActions = [\n  'getAddresses',\n  'getCallsStatus',\n  'getCapabilities',\n  'getChainId',\n  'requestAddresses',\n  'sendCalls',\n  'showCallsStatus',\n  'signMessage',\n  'signTypedData',\n  'showCallsStatus',\n  'waitForCallsStatus',\n  'writeContract',\n] as const satisfies (keyof viem_WalletActions)[]\n\nexport async function addFunds(\n  client: Client,\n  parameters: addFunds.Parameters,\n): Promise<addFunds.ReturnType> {\n  const method = 'wallet_addFunds' as const\n  type Method = typeof method\n  const response = await client.request<\n    Extract<RpcSchema_viem.Wallet[number], { Method: Method }>\n  >({\n    method,\n    params: [z.encode(RpcSchema.wallet_addFunds.Parameters, parameters)],\n  })\n\n  return z.decode(RpcSchema.wallet_addFunds.Response, response)\n}\n\nexport declare namespace addFunds {\n  type Parameters = RpcSchema.wallet_addFunds.Parameters\n\n  type ReturnType = RpcSchema.wallet_addFunds.Response\n}\n\nexport async function getAssets<\n  chain extends Chain | undefined,\n  account extends Account.Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  ...parameters: account extends undefined\n    ? [getAssets.Parameters<account>]\n    : [getAssets.Parameters<account>] | []\n): Promise<getAssets.ReturnType> {\n  const { account = client.account, ...rest } = parameters[0] ?? {}\n\n  const account_ = account ? Account.from(account) : undefined\n  if (!account_) throw new Error('account is required')\n\n  const method = 'wallet_getAssets' as const\n  type Method = typeof method\n  const response = await client.request<\n    Extract<RpcSchema_viem.Wallet[number], { Method: Method }>\n  >({\n    method,\n    params: [\n      z.encode(RpcSchema.wallet_getAssets.Parameters, {\n        ...rest,\n        account: account_.address,\n      }),\n    ],\n  })\n\n  const value = z.decode(RpcSchema.wallet_getAssets.Response, response)\n  const decoded = Object.entries(value).reduce(\n    (acc, [key, value]) => {\n      acc[Hex.toNumber(key as `0x${string}`)] = value\n      return acc\n    },\n    {} as Record<number, ValueOf<typeof value>>,\n  )\n\n  return decoded\n}\n\nexport declare namespace getAssets {\n  type Parameters<account extends Account.Account | undefined = undefined> =\n    Omit<RpcSchema.wallet_getAssets.Parameters, 'account'> &\n      GetAccountParameter<account>\n\n  type ReturnType = RpcSchema.wallet_getAssets.Response\n}\n\nexport async function connect(\n  client: Client,\n  parameters: connect.Parameters = {},\n): Promise<connect.ReturnType> {\n  const { chainIds, ...capabilities } = parameters\n  const method = 'wallet_connect' as const\n  type Method = typeof method\n  const response = await client.request<\n    Extract<RpcSchema_viem.Wallet[number], { Method: Method }>\n  >({\n    method,\n    params: [\n      z.encode(RpcSchema.wallet_connect.Parameters, {\n        capabilities,\n        chainIds,\n      }),\n    ],\n  })\n\n  return z.decode(RpcSchema.wallet_connect.Response, response)\n}\n\nexport declare namespace connect {\n  type Parameters = RpcSchema.wallet_connect.Capabilities &\n    Omit<RpcSchema.wallet_connect.Parameters, 'capabilities'>\n\n  type ReturnType = RpcSchema.wallet_connect.Response\n}\n\nexport async function disconnect(client: Client) {\n  const method = 'wallet_disconnect' as const\n  type Method = typeof method\n  await client.request<\n    Extract<RpcSchema_viem.Wallet[number], { Method: Method }>\n  >({\n    method,\n  } as never)\n}\n\nexport async function getAdmins(\n  client: Client,\n  parameters: getAdmins.Parameters = {},\n): Promise<getAdmins.ReturnType> {\n  const method = 'wallet_getAdmins' as const\n  type Method = typeof method\n  const response = await client.request<\n    Extract<RpcSchema_viem.Wallet[number], { Method: Method }>\n  >({\n    method,\n    params: [z.encode(RpcSchema.wallet_getAdmins.Parameters, parameters)],\n  })\n\n  return z.decode(RpcSchema.wallet_getAdmins.Response, response)\n}\n\nexport declare namespace getAdmins {\n  type Parameters = RpcSchema.wallet_getAdmins.Parameters\n\n  type ReturnType = RpcSchema.wallet_getAdmins.Response\n}\n\nexport async function getPermissions(\n  client: Client,\n  parameters: getPermissions.Parameters = {},\n): Promise<getPermissions.ReturnType> {\n  const method = 'wallet_getPermissions' as const\n  type Method = typeof method\n  const response = await client.request<\n    Extract<RpcSchema_viem.Wallet[number], { Method: Method }>\n  >({\n    method,\n    params: [z.encode(RpcSchema.wallet_getPermissions.Parameters, parameters)],\n  })\n\n  return z.decode(RpcSchema.wallet_getPermissions.Response, response)\n}\n\nexport declare namespace getPermissions {\n  type Parameters = RpcSchema.wallet_getPermissions.Parameters\n\n  type ReturnType = RpcSchema.wallet_getPermissions.Response\n}\n\nexport async function grantAdmin(\n  client: Client,\n  parameters: grantAdmin.Parameters,\n): Promise<grantAdmin.ReturnType> {\n  const method = 'wallet_grantAdmin' as const\n  type Method = typeof method\n  const response = await client.request<\n    Extract<RpcSchema_viem.Wallet[number], { Method: Method }>\n  >({\n    method,\n    params: [z.encode(RpcSchema.wallet_grantAdmin.Parameters, parameters)],\n  })\n\n  return z.decode(RpcSchema.wallet_grantAdmin.Response, response)\n}\n\nexport declare namespace grantAdmin {\n  type Parameters = RpcSchema.wallet_grantAdmin.Capabilities &\n    Omit<RpcSchema.wallet_grantAdmin.Parameters, 'capabilities'>\n\n  type ReturnType = RpcSchema.wallet_grantAdmin.Response\n}\n\nexport async function grantPermissions(\n  client: Client,\n  parameters: grantPermissions.Parameters,\n): Promise<grantPermissions.ReturnType> {\n  const method = 'wallet_grantPermissions' as const\n  type Method = typeof method\n  const response = await client.request<\n    Extract<RpcSchema_viem.Wallet[number], { Method: Method }>\n  >({\n    method,\n    params: [\n      z.encode(RpcSchema.wallet_grantPermissions.Parameters, parameters),\n    ],\n  })\n\n  return z.decode(RpcSchema.wallet_grantPermissions.Response, response)\n}\n\nexport declare namespace grantPermissions {\n  type Parameters = RpcSchema.wallet_grantPermissions.Parameters\n\n  type ReturnType = RpcSchema.wallet_grantPermissions.Response\n}\n\nexport async function prepareCalls<\n  const calls extends readonly unknown[] = readonly unknown[],\n>(\n  client: Client,\n  parameters: prepareCalls.Parameters<calls>,\n): Promise<prepareCalls.ReturnType> {\n  const method = 'wallet_prepareCalls' as const\n  type Method = typeof method\n  const response = await client.request<\n    Extract<RpcSchema_viem.Wallet[number], { Method: Method }>\n  >({\n    method,\n    params: [\n      z.encode(RpcSchema.wallet_prepareCalls.Parameters, {\n        ...parameters,\n        calls: (parameters.calls ?? []).map((c) => {\n          const call = c as Call\n          const data = (() => {\n            if (!call.abi) return call.data\n            return encodeFunctionData(call)\n          })()\n          return {\n            ...call,\n            data,\n          }\n        }),\n      }),\n    ],\n  })\n\n  return z.decode(RpcSchema.wallet_prepareCalls.Response, response)\n}\n\nexport declare namespace prepareCalls {\n  type Parameters<calls extends readonly unknown[] = readonly unknown[]> = Omit<\n    RpcSchema.wallet_prepareCalls.Parameters,\n    'calls'\n  > & {\n    calls?: Calls<Narrow<calls>> | undefined\n  }\n\n  type ReturnType = RpcSchema.wallet_prepareCalls.Response\n}\n\nexport async function revokeAdmin(\n  client: Client,\n  parameters: revokeAdmin.Parameters,\n) {\n  const method = 'wallet_revokeAdmin' as const\n  type Method = typeof method\n  await client.request<\n    Extract<RpcSchema_viem.Wallet[number], { Method: Method }>\n  >({\n    method,\n    params: [z.encode(RpcSchema.wallet_revokeAdmin.Parameters, parameters)],\n  })\n  return undefined\n}\n\nexport declare namespace revokeAdmin {\n  type Parameters = RpcSchema.wallet_revokeAdmin.Parameters\n}\n\nexport async function revokePermissions(\n  client: Client,\n  parameters: revokePermissions.Parameters,\n) {\n  const { address, id, ...capabilities } = parameters\n  const method = 'wallet_revokePermissions' as const\n  type Method = typeof method\n  await client.request<\n    Extract<RpcSchema_viem.Wallet[number], { Method: Method }>\n  >({\n    method,\n    params: [\n      z.encode(RpcSchema.wallet_revokePermissions.Parameters, {\n        address,\n        capabilities,\n        id,\n      }),\n    ],\n  })\n  return undefined\n}\n\nexport declare namespace revokePermissions {\n  type Parameters = RpcSchema.wallet_revokePermissions.Capabilities &\n    Omit<RpcSchema.wallet_revokePermissions.Parameters, 'capabilities'>\n}\n\nexport async function sendPreparedCalls(\n  client: Client,\n  parameters: sendPreparedCalls.Parameters,\n): Promise<sendPreparedCalls.ReturnType> {\n  const method = 'wallet_sendPreparedCalls' as const\n  type Method = typeof method\n  const response = await client.request<\n    Extract<RpcSchema_viem.Wallet[number], { Method: Method }>\n  >({\n    method,\n    params: [\n      z.encode(RpcSchema.wallet_sendPreparedCalls.Parameters, parameters),\n    ],\n  })\n\n  return z.decode(RpcSchema.wallet_sendPreparedCalls.Response, response)\n}\n\nexport declare namespace sendPreparedCalls {\n  type Parameters = RpcSchema.wallet_sendPreparedCalls.Parameters\n\n  type ReturnType = RpcSchema.wallet_sendPreparedCalls.Response\n}\n\nexport async function upgradeAccount(\n  client: Client,\n  parameters: upgradeAccount.Parameters,\n): Promise<upgradeAccount.ReturnType> {\n  const { account, chainId, ...capabilities } = parameters\n\n  const method = 'wallet_prepareUpgradeAccount' as const\n  type Method = typeof method\n  const { context, digests } = await client.request<\n    Extract<RpcSchema_viem.Wallet[number], { Method: Method }>\n  >({\n    method,\n    params: [\n      z.encode(RpcSchema.wallet_prepareUpgradeAccount.Parameters, {\n        address: account.address,\n        capabilities,\n        chainId,\n      }),\n    ],\n  })\n\n  const signatures = {\n    auth: await account.sign({ hash: digests.auth }),\n    exec: await account.sign({ hash: digests.exec }),\n  }\n\n  const method_upgrade = 'wallet_upgradeAccount' as const\n  type Method_upgrade = typeof method_upgrade\n  const response = await client.request<\n    Extract<RpcSchema_viem.Wallet[number], { Method: Method_upgrade }>\n  >({\n    method: method_upgrade,\n    params: [\n      z.encode(RpcSchema.wallet_upgradeAccount.Parameters, {\n        context,\n        signatures,\n      }),\n    ],\n  })\n\n  return z.decode(RpcSchema.wallet_upgradeAccount.Response, response)\n}\n\nexport declare namespace upgradeAccount {\n  type Parameters = RpcSchema.wallet_prepareUpgradeAccount.Capabilities &\n    Omit<\n      RpcSchema.wallet_prepareUpgradeAccount.Parameters,\n      'address' | 'capabilities'\n    > & {\n      account: PrivateKeyAccount | Account.Account\n    }\n\n  type ReturnType = RpcSchema.wallet_upgradeAccount.Response\n}\n\nexport type Decorator<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account.Account | undefined = Account.Account | undefined,\n> = Pick<\n  viem_WalletActions<chain, account>,\n  (typeof supportedWalletActions)[number]\n> & {\n  connect: (parameters: connect.Parameters) => Promise<connect.ReturnType>\n  disconnect: () => Promise<void>\n  getPermissions: (\n    parameters: getPermissions.Parameters,\n  ) => Promise<getPermissions.ReturnType>\n  grantPermissions: (\n    parameters: grantPermissions.Parameters,\n  ) => Promise<grantPermissions.ReturnType>\n  prepareCalls: (\n    parameters: prepareCalls.Parameters,\n  ) => Promise<prepareCalls.ReturnType>\n  revokePermissions: (parameters: revokePermissions.Parameters) => Promise<void>\n  sendPreparedCalls: (\n    parameters: sendPreparedCalls.Parameters,\n  ) => Promise<sendPreparedCalls.ReturnType>\n  upgradeAccount: (\n    parameters: upgradeAccount.Parameters,\n  ) => Promise<upgradeAccount.ReturnType>\n}\n\nexport function decorator<\n  chain extends Chain | undefined,\n  account extends Account.Account | undefined,\n>(client: Client<Transport, chain, account>): Decorator<chain, account> {\n  return {\n    connect: (parameters) => connect(client, parameters),\n    disconnect: () => disconnect(client),\n    getAddresses: () => getAddresses(client),\n    getCallsStatus: (parameters) => getCallsStatus(client, parameters),\n    getCapabilities: () => getCapabilities(client),\n    getChainId: () => getChainId(client),\n    getPermissions: (parameters) => getPermissions(client, parameters),\n    grantPermissions: (parameters) => grantPermissions(client, parameters),\n    prepareCalls: (parameters) => prepareCalls(client, parameters),\n    requestAddresses: () => requestAddresses(client),\n    revokePermissions: (parameters) => revokePermissions(client, parameters),\n    sendCalls: (parameters) => sendCalls(client, parameters),\n    sendPreparedCalls: (parameters) => sendPreparedCalls(client, parameters),\n    showCallsStatus: (parameters) => showCallsStatus(client, parameters),\n    signMessage: (parameters) => signMessage(client, parameters),\n    signTypedData: (parameters) => signTypedData(client, parameters),\n    upgradeAccount: (parameters) => upgradeAccount(client, parameters),\n    waitForCallsStatus: (parameters) => waitForCallsStatus(client, parameters),\n    writeContract: (parameters) => writeContract(client, parameters),\n  }\n}\n", "import {\n  type BaseError,\n  type Config,\n  type Connector,\n  ConnectorAlreadyConnectedError,\n  type CreateConnectorFn,\n  ProviderNotFoundError,\n} from '@wagmi/core'\nimport {\n  type ConnectReturnType,\n  getConnectorClient,\n  disconnect as wagmi_disconnect,\n} from '@wagmi/core/actions'\nimport {\n  type Address,\n  type Chain,\n  ChainMismatchError,\n  createClient,\n  custom,\n  type EIP1193Provider,\n} from 'viem'\nimport type { PartialBy } from '../../core/internal/types.js'\nimport type * as RpcSchema from '../../core/RpcSchema.js'\nimport * as AccountActions from '../../viem/AccountActions.js'\nimport * as WalletActions from '../../viem/WalletActions.js'\nimport type { ChainIdParameter, ConnectorParameter } from './types.js'\n\nexport async function connect<config extends Config>(\n  config: config,\n  parameters: connect.Parameters,\n): Promise<connect.ReturnType> {\n  // \"Register\" connector if not already created\n  let connector: Connector\n  if (typeof parameters.connector === 'function') {\n    connector = config._internal.connectors.setup(parameters.connector)\n  } else connector = parameters.connector\n\n  // Check if connector is already connected\n  if (connector.uid === config.state.current && !parameters.force)\n    throw new ConnectorAlreadyConnectedError()\n\n  try {\n    config.setState((x) => ({ ...x, status: 'connecting' }))\n    connector.emitter.emit('message', { type: 'connecting' })\n\n    const provider = (await connector.getProvider()) as\n      | EIP1193Provider\n      | undefined\n    if (!provider) throw new ProviderNotFoundError()\n\n    const client = createClient({\n      transport: (opts) => custom(provider)({ ...opts, retryCount: 0 }),\n    })\n\n    const chainIds_request = parameters.chainIds ?? [config.state.chainId]\n\n    const { accounts, chainIds } = await WalletActions.connect(client, {\n      ...parameters,\n      chainIds: chainIds_request,\n    })\n    const addresses = accounts.map((x) => x.address) as unknown as readonly [\n      Address,\n      ...Address[],\n    ]\n\n    // we already connected, but call `connector.connect` so connector even listeners are set up\n    await connector.connect({\n      chainId: chainIds_request[0],\n      isReconnecting: true,\n    })\n\n    connector.emitter.off('connect', config._internal.events.connect)\n    connector.emitter.on('change', config._internal.events.change)\n    connector.emitter.on('disconnect', config._internal.events.disconnect)\n\n    await config.storage?.setItem('recentConnectorId', connector.id)\n    config.setState((x) => ({\n      ...x,\n      connections: new Map(x.connections).set(connector.uid, {\n        accounts: addresses,\n        chainId: chainIds[0]!,\n        connector,\n      }),\n      current: connector.uid,\n      status: 'connected',\n    }))\n\n    return { accounts, chainIds }\n  } catch (error) {\n    config.setState((x) => ({\n      ...x,\n      // Keep existing connector connected in case of error\n      status: x.current ? 'connected' : 'disconnected',\n    }))\n    throw error\n  }\n}\n\nexport declare namespace connect {\n  type Parameters = RpcSchema.wallet_connect.Capabilities & {\n    connector: Connector | CreateConnectorFn\n    chainIds?: readonly [number, ...number[]] | undefined\n    force?: boolean | undefined\n  }\n\n  type ReturnType = RpcSchema.wallet_connect.Response\n\n  // TODO: Exhaustive ErrorType\n  type ErrorType = BaseError\n}\n\nexport async function disconnect(\n  config: Config,\n  parameters: disconnect.Parameters = {},\n): Promise<disconnect.ReturnType> {\n  const connector = (() => {\n    if (parameters.connector) return parameters.connector\n    const { connections, current } = config.state\n    const connection = connections.get(current!)\n    return connection?.connector\n  })()\n\n  const provider = (await connector?.getProvider()) as\n    | EIP1193Provider\n    | undefined\n\n  await wagmi_disconnect(config, parameters)\n\n  if (!provider) return\n\n  const client = createClient({\n    transport: (opts) => custom(provider)({ ...opts, retryCount: 0 }),\n  })\n  await WalletActions.disconnect(client)\n}\n\nexport declare namespace disconnect {\n  type Parameters = ConnectorParameter\n\n  // biome-ignore lint/suspicious/noConfusingVoidType: _\n  type ReturnType = void\n\n  // TODO: Exhaustive ErrorType\n  type ErrorType = BaseError\n}\n\nexport async function addFunds<config extends Config>(\n  config: config,\n  parameters: addFunds.Parameters<config>,\n): Promise<addFunds.ReturnType> {\n  const { address, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account: address,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return WalletActions.addFunds(client, parameters)\n}\n\nexport declare namespace addFunds {\n  type Parameters<config extends Config = Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    WalletActions.addFunds.Parameters\n\n  type ReturnType = WalletActions.addFunds.ReturnType\n\n  // TODO: Exhaustive ErrorType\n  type ErrorType = BaseError\n}\n\nexport async function getAdmins<config extends Config>(\n  config: config,\n  parameters: getAdmins.Parameters<config>,\n): Promise<getAdmins.ReturnType> {\n  const { address, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account: address,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return WalletActions.getAdmins(client, parameters)\n}\n\nexport declare namespace getAdmins {\n  type Parameters<config extends Config = Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    WalletActions.getAdmins.Parameters\n\n  type ReturnType = WalletActions.getAdmins.ReturnType\n\n  // TODO: Exhaustive ErrorType\n  type ErrorType = BaseError\n}\n\nexport async function getAssets<config extends Config>(\n  config: config,\n  parameters: getAssets.Parameters = {},\n): Promise<getAssets.ReturnType> {\n  const { account, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    connector,\n  })\n\n  return WalletActions.getAssets(client as any, parameters)\n}\n\nexport declare namespace getAssets {\n  type Parameters = ConnectorParameter &\n    PartialBy<WalletActions.getAssets.Parameters, 'account'>\n\n  type ReturnType = WalletActions.getAssets.ReturnType\n\n  // TODO: Exhaustive ErrorType\n  type ErrorType = BaseError\n}\n\nexport async function getPermissions<config extends Config>(\n  config: config,\n  parameters: getPermissions.Parameters<config> = {},\n): Promise<getPermissions.ReturnType> {\n  const { address, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account: address,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return WalletActions.getPermissions(client, parameters)\n}\n\nexport declare namespace getPermissions {\n  type Parameters<config extends Config = Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    WalletActions.getPermissions.Parameters\n\n  type ReturnType = WalletActions.getPermissions.ReturnType\n\n  // TODO: Exhaustive ErrorType\n  type ErrorType = BaseError\n}\n\nexport async function grantAdmin<config extends Config>(\n  config: config,\n  parameters: grantAdmin.Parameters<config>,\n): Promise<grantAdmin.ReturnType> {\n  const { address, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account: address,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return WalletActions.grantAdmin(client, parameters)\n}\n\nexport declare namespace grantAdmin {\n  type Parameters<config extends Config = Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    WalletActions.grantAdmin.Parameters\n\n  type ReturnType = WalletActions.grantAdmin.ReturnType\n\n  // TODO: Exhaustive ErrorType\n  type ErrorType = BaseError\n}\n\nexport async function grantPermissions<config extends Config>(\n  config: config,\n  parameters: grantPermissions.Parameters<config>,\n): Promise<grantPermissions.ReturnType> {\n  const { address, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account: address,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return WalletActions.grantPermissions(client, parameters)\n}\n\nexport declare namespace grantPermissions {\n  type Parameters<config extends Config = Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    WalletActions.grantPermissions.Parameters\n\n  type ReturnType = WalletActions.grantPermissions.ReturnType\n\n  // TODO: Exhaustive ErrorType\n  type ErrorType = BaseError\n}\n\nexport async function revokeAdmin<config extends Config>(\n  config: config,\n  parameters: revokeAdmin.Parameters<config>,\n) {\n  const { address, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account: address,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return WalletActions.revokeAdmin(client, parameters)\n}\n\nexport declare namespace revokeAdmin {\n  type Parameters<config extends Config = Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    WalletActions.revokeAdmin.Parameters\n\n  // TODO: Exhaustive ErrorType\n  type ErrorType = BaseError\n}\n\nexport async function revokePermissions<config extends Config>(\n  config: config,\n  parameters: revokePermissions.Parameters<config>,\n) {\n  const { address, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account: address,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return WalletActions.revokePermissions(client, parameters)\n}\n\nexport declare namespace revokePermissions {\n  type Parameters<config extends Config = Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    WalletActions.revokePermissions.Parameters\n\n  // TODO: Exhaustive ErrorType\n  type ErrorType = BaseError\n}\n\nexport async function upgradeAccount<config extends Config>(\n  config: config,\n  parameters: upgradeAccount.Parameters<config>,\n): Promise<upgradeAccount.ReturnType> {\n  // \"Register\" connector if not already created\n  let connector: Connector\n  if (typeof parameters.connector === 'function') {\n    connector = config._internal.connectors.setup(parameters.connector)\n  } else connector = parameters.connector\n\n  // Check if connector is already connected\n  if (connector.uid === config.state.current)\n    throw new ConnectorAlreadyConnectedError()\n\n  if (parameters.chainId && parameters.chainId !== config.state.chainId)\n    throw new ChainMismatchError({\n      chain:\n        config.chains.find((chain) => chain.id === parameters.chainId) ??\n        ({\n          id: parameters.chainId,\n          name: `Chain ${parameters.chainId}`,\n        } as Chain),\n      currentChainId: config.state.chainId,\n    })\n\n  try {\n    config.setState((x) => ({ ...x, status: 'connecting' }))\n    connector.emitter.emit('message', { type: 'connecting' })\n\n    const provider = (await connector.getProvider()) as\n      | EIP1193Provider\n      | undefined\n    if (!provider) throw new ProviderNotFoundError()\n\n    const client = createClient({\n      transport: (opts) => custom(provider)({ ...opts, retryCount: 0 }),\n    })\n\n    await WalletActions.upgradeAccount(client, parameters)\n\n    // we already connected, but call `connector.connect` so connector even listeners are set up\n    const data = await connector.connect({\n      chainId: parameters.chainId,\n      isReconnecting: true,\n    })\n    const accounts = data.accounts as readonly [Address, ...Address[]]\n\n    connector.emitter.off('connect', config._internal.events.connect)\n    connector.emitter.on('change', config._internal.events.change)\n    connector.emitter.on('disconnect', config._internal.events.disconnect)\n\n    await config.storage?.setItem('recentConnectorId', connector.id)\n    config.setState((x) => ({\n      ...x,\n      connections: new Map(x.connections).set(connector.uid, {\n        accounts,\n        chainId: data.chainId,\n        connector,\n      }),\n      current: connector.uid,\n      status: 'connected',\n    }))\n\n    return { accounts, chainId: data.chainId }\n  } catch (error) {\n    config.setState((x) => ({\n      ...x,\n      // Keep existing connector connected in case of error\n      status: x.current ? 'connected' : 'disconnected',\n    }))\n    throw error\n  }\n}\n\nexport declare namespace upgradeAccount {\n  type Parameters<config extends Config = Config> = ChainIdParameter<config> &\n    WalletActions.upgradeAccount.Parameters & {\n      connector: Connector | CreateConnectorFn\n    }\n\n  type ReturnType<config extends Config = Config> = ConnectReturnType<config>\n\n  // TODO: Exhaustive ErrorType\n  type ErrorType = BaseError\n}\n\nexport async function verifyEmail<config extends Config>(\n  config: config,\n  parameters: verifyEmail.Parameters<config>,\n): Promise<verifyEmail.ReturnType> {\n  const { chainId, connector, walletAddress } = parameters\n\n  const client = await getConnectorClient(config, {\n    account: walletAddress,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return AccountActions.verifyEmail(client, parameters)\n}\n\nexport declare namespace verifyEmail {\n  type Parameters<config extends Config = Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    AccountActions.verifyEmail.Parameters\n\n  type ReturnType = AccountActions.verifyEmail.ReturnType\n\n  // TODO: Exhaustive ErrorType\n  type ErrorType = BaseError\n}\n", "import {\n  ChainNotConfiguredError,\n  type Connector,\n  createConnector,\n} from '@wagmi/core'\nimport {\n  type Address,\n  numberToHex,\n  type ProviderConnectInfo,\n  type RpcError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  withRetry,\n} from 'viem'\nimport * as z from 'zod/mini'\nimport type * as Chains from '../core/Chains.js'\nimport type { ExactPartial } from '../core/internal/types.js'\nimport type * as Porto from '../core/Porto.js'\nimport * as RpcSchema from '../core/RpcSchema.js'\n\nexport type PortoParameters<\n  chains extends readonly [Chains.Chain, ...Chains.Chain[]] = readonly [\n    Chains.Chain,\n    ...Chains.Chain[],\n  ],\n> = ExactPartial<Porto.Config<chains>>\n\nexport function porto<\n  const chains extends readonly [Chains.Chain, ...Chains.Chain[]],\n>(parameters: PortoParameters<chains> = {}) {\n  type Provider = ReturnType<typeof Porto.create>['provider']\n  type Properties = {\n    connect<withCapabilities extends boolean = false>(parameters?: {\n      chainId?: number | undefined\n      capabilities?:\n        | (RpcSchema.wallet_connect.Capabilities & {\n            force?: boolean | undefined\n          })\n        | undefined\n      isReconnecting?: boolean | undefined\n      withCapabilities?: withCapabilities | boolean | undefined\n    }): Promise<{\n      accounts: withCapabilities extends true\n        ? readonly {\n            address: Address\n            capabilities: RpcSchema.wallet_connect.ResponseCapabilities\n          }[]\n        : readonly Address[]\n      chainId: number\n    }>\n    getPortoInstance(): Promise<\n      Porto.Porto<readonly [Chains.Chain, ...Chains.Chain[]]>\n    >\n    onConnect(connectInfo: ProviderConnectInfo): void\n  }\n\n  return createConnector<Provider, Properties>((wagmiConfig) => {\n    const chains = wagmiConfig.chains ?? parameters.chains ?? []\n\n    const transports = (() => {\n      if (wagmiConfig.transports) return wagmiConfig.transports\n      return parameters.transports\n    })()\n\n    let porto_promise: Promise<any> | undefined\n\n    let accountsChanged: Connector['onAccountsChanged'] | undefined\n    let chainChanged: Connector['onChainChanged'] | undefined\n    let connect: Connector['onConnect'] | undefined\n    let disconnect: Connector['onDisconnect'] | undefined\n\n    return {\n      async connect({ chainId = chains[0].id, ...rest } = {}) {\n        const isReconnecting =\n          ('isReconnecting' in rest && rest.isReconnecting) || false\n        const withCapabilities =\n          ('withCapabilities' in rest && rest.withCapabilities) || false\n\n        let accounts: readonly (Address | { address: Address })[] = []\n        let currentChainId: number | undefined\n\n        if (isReconnecting) {\n          ;[accounts, currentChainId] = await Promise.all([\n            this.getAccounts().catch(() => []),\n            this.getChainId().catch(() => undefined),\n          ])\n          if (chainId && currentChainId !== chainId) {\n            const chain = await this.switchChain!({ chainId }).catch(\n              (error) => {\n                if (error.code === UserRejectedRequestError.code) throw error\n                return { id: currentChainId }\n              },\n            )\n            currentChainId = chain?.id ?? currentChainId\n          }\n        }\n\n        const provider = (await this.getProvider()) as Provider\n\n        try {\n          if (!accounts?.length && !isReconnecting) {\n            const res = await provider.request({\n              method: 'wallet_connect',\n              params: [\n                {\n                  ...('capabilities' in rest\n                    ? {\n                        capabilities: z.encode(\n                          RpcSchema.wallet_connect.Capabilities,\n                          rest.capabilities ?? {},\n                        ),\n                      }\n                    : {}),\n                  chainIds: [\n                    numberToHex(chainId),\n                    ...chains\n                      .filter((x) => x.id !== chainId)\n                      .map((x) => numberToHex(x.id)),\n                  ],\n                },\n              ],\n            })\n            accounts = res.accounts\n            currentChainId = Number(res.chainIds[0])\n          }\n\n          if (!currentChainId) throw new ChainNotConfiguredError()\n\n          // Manage EIP-1193 event listeners\n          // https://eips.ethereum.org/EIPS/eip-1193#events\n          if (connect) {\n            provider.removeListener('connect', connect)\n            connect = undefined\n          }\n          if (!accountsChanged) {\n            accountsChanged = this.onAccountsChanged.bind(this)\n            // Porto Provider uses Ox, which uses `readonly Address.Address[]` for `accountsChanged`,\n            // while Connector `accountsChanged` is `string[]`\n            provider.on('accountsChanged', accountsChanged as never)\n          }\n          if (!chainChanged) {\n            chainChanged = this.onChainChanged.bind(this)\n            provider.on('chainChanged', chainChanged)\n          }\n          if (!disconnect) {\n            disconnect = this.onDisconnect.bind(this)\n            provider.on('disconnect', disconnect)\n          }\n\n          return {\n            accounts: accounts.map((account) => {\n              if (typeof account === 'object')\n                return withCapabilities ? account : account.address\n              return withCapabilities\n                ? { address: account, capabilities: {} }\n                : account\n            }) as never,\n            chainId: currentChainId,\n          }\n        } catch (err) {\n          const error = err as RpcError\n          if (error.code === UserRejectedRequestError.code)\n            throw new UserRejectedRequestError(error)\n          throw error\n        }\n      },\n      async disconnect() {\n        const provider = await this.getProvider()\n\n        if (chainChanged) {\n          provider.removeListener('chainChanged', chainChanged)\n          chainChanged = undefined\n        }\n        if (disconnect) {\n          provider.removeListener('disconnect', disconnect)\n          disconnect = undefined\n        }\n        if (!connect) {\n          connect = this.onConnect.bind(this)\n          provider.on('connect', connect)\n        }\n\n        await provider.request({ method: 'wallet_disconnect' })\n      },\n      async getAccounts() {\n        const provider = await this.getProvider()\n        return provider.request({ method: 'eth_accounts' })\n      },\n      async getChainId() {\n        const provider = await this.getProvider()\n        const hexChainId = await provider.request({\n          method: 'eth_chainId',\n        })\n        return Number(hexChainId)\n      },\n      async getPortoInstance() {\n        porto_promise ??= (async () => {\n          const Porto = await import('../core/Porto.js')\n          return Porto.create({\n            ...parameters,\n            announceProvider: false,\n            chains: chains as never,\n            transports: transports as never,\n          })\n        })()\n        return await porto_promise\n      },\n      async getProvider() {\n        return (await this.getPortoInstance()).provider\n      },\n      icon: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDIyIiBoZWlnaHQ9IjQyMiIgdmlld0JveD0iMCAwIDQyMiA0MjIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MjIiIGhlaWdodD0iNDIyIiBmaWxsPSJibGFjayIvPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMV8xNSkiPgo8cGF0aCBkPSJNODEgMjg2LjM2NkM4MSAyODAuODkzIDg1LjQ1MDUgMjc2LjQ1NSA5MC45NDA0IDI3Ni40NTVIMzI5LjUxMUMzMzUuMDAxIDI3Ni40NTUgMzM5LjQ1MiAyODAuODkzIDMzOS40NTIgMjg2LjM2NlYzMDYuMTg4QzMzOS40NTIgMzExLjY2MiAzMzUuMDAxIDMxNi4wOTkgMzI5LjUxMSAzMTYuMDk5SDkwLjk0MDRDODUuNDUwNSAzMTYuMDk5IDgxIDMxMS42NjIgODEgMzA2LjE4OFYyODYuMzY2WiIgZmlsbD0id2hpdGUiIGZpbGwtb3BhY2l0eT0iMC41Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTAuOTQwNCAyMzQuODI4Qzg1LjQ1MDUgMjM0LjgyOCA4MSAyMzkuMjY2IDgxIDI0NC43MzlWMjcxLjUzMUM4My44NDMyIDI2OS42MzMgODcuMjYyMiAyNjguNTI2IDkwLjk0MDQgMjY4LjUyNkgzMjkuNTExQzMzMy4xODggMjY4LjUyNiAzMzYuNjA4IDI2OS42MzMgMzM5LjQ1MiAyNzEuNTMxVjI0NC43MzlDMzM5LjQ1MiAyMzkuMjY2IDMzNS4wMDEgMjM0LjgyOCAzMjkuNTExIDIzNC44MjhIOTAuOTQwNFpNMzM5LjQ1MiAyODYuMzY2QzMzOS40NTIgMjgwLjg5MyAzMzUuMDAxIDI3Ni40NTUgMzI5LjUxMSAyNzYuNDU1SDkwLjk0MDRDODUuNDUwNSAyNzYuNDU1IDgxIDI4MC44OTMgODEgMjg2LjM2NlYzMDYuMTlDODEgMzExLjY2NCA4NS40NTA1IDMxNi4xMDEgOTAuOTQwNCAzMTYuMTAxSDMyOS41MTFDMzM1LjAwMSAzMTYuMTAxIDMzOS40NTIgMzExLjY2NCAzMzkuNDUyIDMwNi4xOVYyODYuMzY2WiIgZmlsbD0id2hpdGUiIGZpbGwtb3BhY2l0eT0iMC41Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTAuOTQwNCAxOTMuMjAxQzg1LjQ1MDUgMTkzLjIwMSA4MSAxOTcuNjM4IDgxIDIwMy4xMTJWMjI5LjkwM0M4My44NDMyIDIyOC4wMDYgODcuMjYyMiAyMjYuODk5IDkwLjk0MDQgMjI2Ljg5OUgzMjkuNTExQzMzMy4xODggMjI2Ljg5OSAzMzYuNjA4IDIyOC4wMDYgMzM5LjQ1MiAyMjkuOTAzVjIwMy4xMTJDMzM5LjQ1MiAxOTcuNjM4IDMzNS4wMDEgMTkzLjIwMSAzMjkuNTExIDE5My4yMDFIOTAuOTQwNFpNMzM5LjQ1MiAyNDQuNzM5QzMzOS40NTIgMjM5LjI2NSAzMzUuMDAxIDIzNC44MjggMzI5LjUxMSAyMzQuODI4SDkwLjk0MDRDODUuNDUwNSAyMzQuODI4IDgxIDIzOS4yNjUgODEgMjQ0LjczOVYyNzEuNTNDODEuMjE3NSAyNzEuMzg1IDgxLjQzODMgMjcxLjI0NSA4MS42NjI0IDI3MS4xMDlDODMuODMyNSAyNjkuNzk0IDg2LjMwNTQgMjY4LjkyNyA4OC45NTIzIDI2OC42MzVDODkuNjA1MSAyNjguNTYzIDkwLjI2ODQgMjY4LjUyNiA5MC45NDA0IDI2OC41MjZIMzI5LjUxMUMzMzAuMTgzIDI2OC41MjYgMzMwLjg0NiAyNjguNTYzIDMzMS40OTggMjY4LjYzNUMzMzQuNDE5IDI2OC45NTcgMzM3LjEyOCAyNjkuOTggMzM5LjQ1MiAyNzEuNTNWMjQ0LjczOVpNMzM5LjQ1MiAyODYuMzY2QzMzOS40NTIgMjgxLjAyMSAzMzUuMjA2IDI3Ni42NjMgMzI5Ljg5MyAyNzYuNDYyQzMyOS43NjcgMjc2LjQ1NyAzMjkuNjQgMjc2LjQ1NSAzMjkuNTExIDI3Ni40NTVIOTAuOTQwNEM4NS40NTA1IDI3Ni40NTUgODEgMjgwLjg5MyA4MSAyODYuMzY2VjMwNi4xODhDODEgMzExLjY2MiA4NS40NTA1IDMxNi4xMDEgOTAuOTQwNCAzMTYuMTAxSDMyOS41MTFDMzM1LjAwMSAzMTYuMTAxIDMzOS40NTIgMzExLjY2MiAzMzkuNDUyIDMwNi4xODhWMjg2LjM2NloiIGZpbGw9IndoaXRlIiBmaWxsLW9wYWNpdHk9IjAuNSIvPgo8cGF0aCBvcGFjaXR5PSIwLjMiIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTguMDE0NiAxMDRDODguNjE3NyAxMDQgODEgMTExLjU5NSA4MSAxMjAuOTY1VjE4OC4yNzZDODMuODQzMiAxODYuMzc5IDg3LjI2MjIgMTg1LjI3MiA5MC45NDA0IDE4NS4yNzJIMzI5LjUxMUMzMzMuMTg4IDE4NS4yNzIgMzM2LjYwOCAxODYuMzc5IDMzOS40NTIgMTg4LjI3NlYxMjAuOTY1QzMzOS40NTIgMTExLjU5NSAzMzEuODMzIDEwNCAzMjIuNDM3IDEwNEg5OC4wMTQ2Wk0zMzkuNDUyIDIwMy4xMTJDMzM5LjQ1MiAxOTcuNjM4IDMzNS4wMDEgMTkzLjIwMSAzMjkuNTExIDE5My4yMDFIOTAuOTQwNEM4NS40NTA1IDE5My4yMDEgODEgMTk3LjYzOCA4MSAyMDMuMTEyVjIyOS45MDNDODEuMjE3NSAyMjkuNzU4IDgxLjQzODMgMjI5LjYxOCA4MS42NjI0IDIyOS40ODJDODMuODMyNSAyMjguMTY3IDg2LjMwNTQgMjI3LjMgODguOTUyMyAyMjcuMDA4Qzg5LjYwNTEgMjI2LjkzNiA5MC4yNjg0IDIyNi44OTkgOTAuOTQwNCAyMjYuODk5SDMyOS41MTFDMzMwLjE4MyAyMjYuODk5IDMzMC44NDYgMjI2LjkzNiAzMzEuNDk4IDIyNy4wMDhDMzM0LjQxOSAyMjcuMzMgMzM3LjEyOCAyMjguMzUyIDMzOS40NTIgMjI5LjkwM1YyMDMuMTEyWk0zMzkuNDUyIDI0NC43MzlDMzM5LjQ1MiAyMzkuMzkzIDMzNS4yMDYgMjM1LjAzNiAzMjkuODkzIDIzNC44MzVDMzI5Ljc2NyAyMzQuODMgMzI5LjY0IDIzNC44MjggMzI5LjUxMSAyMzQuODI4SDkwLjk0MDRDODUuNDUwNSAyMzQuODI4IDgxIDIzOS4yNjUgODEgMjQ0LjczOVYyNzEuNTNMODEuMDcwNyAyNzEuNDgzQzgxLjI2NTMgMjcxLjM1NSA4MS40NjI1IDI3MS4yMyA4MS42NjI0IDI3MS4xMDlDODEuOTA4MyAyNzAuOTYgODIuMTU4MSAyNzAuODE3IDgyLjQxMTcgMjcwLjY3OUM4NC4zOTUzIDI2OS42MDUgODYuNjA1NCAyNjguODk0IDg4Ljk1MjMgMjY4LjYzNUM4OS4wMDUyIDI2OC42MjkgODkuMDU4IDI2OC42MjQgODkuMTExIDI2OC42MThDODkuNzEyNSAyNjguNTU3IDkwLjMyMjggMjY4LjUyNiA5MC45NDA0IDI2OC41MjZIMzI5LjUxMUMzMjkuNzM4IDI2OC41MjYgMzI5Ljk2NSAyNjguNTMgMzMwLjE5MiAyNjguNTM5QzMzMC42MzEgMjY4LjU1NSAzMzEuMDY3IDI2OC41ODcgMzMxLjQ5OCAyNjguNjM1QzMzNC40MTkgMjY4Ljk1NyAzMzcuMTI4IDI2OS45OCAzMzkuNDUyIDI3MS41M1YyNDQuNzM5Wk0zMzkuNDUyIDI4Ni4zNjZDMzM5LjQ1MiAyODEuMDIxIDMzNS4yMDYgMjc2LjY2MyAzMjkuODkzIDI3Ni40NjJMMzI5Ljg2NSAyNzYuNDYxQzMyOS43NDggMjc2LjQ1NyAzMjkuNjI5IDI3Ni40NTUgMzI5LjUxMSAyNzYuNDU1SDkwLjk0MDRDODUuNDUwNSAyNzYuNDU1IDgxIDI4MC44OTMgODEgMjg2LjM2NlYzMDYuMTg4QzgxIDMxMS42NjIgODUuNDUwNSAzMTYuMTAxIDkwLjk0MDQgMzE2LjEwMUgzMjkuNTExQzMzNS4wMDEgMzE2LjEwMSAzMzkuNDUyIDMxMS42NjIgMzM5LjQ1MiAzMDYuMTg4VjI4Ni4zNjZaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMjY5Ljg2OCAxMzEuNzUyQzI2OS44NjggMTI2LjI3OCAyNzQuMzE4IDEyMS44NCAyNzkuODA4IDEyMS44NEgzMTEuNjE4QzMxNy4xMDggMTIxLjg0IDMyMS41NTggMTI2LjI3OCAzMjEuNTU4IDEzMS43NTJWMTYxLjQ4NUMzMjEuNTU4IDE2Ni45NTkgMzE3LjEwOCAxNzEuMzk2IDMxMS42MTggMTcxLjM5NkgyNzkuODA4QzI3NC4zMTggMTcxLjM5NiAyNjkuODY4IDE2Ni45NTkgMjY5Ljg2OCAxNjEuNDg1VjEzMS43NTJaIiBmaWxsPSJ3aGl0ZSIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzFfMTUiPgo8cmVjdCB3aWR0aD0iMjU5IiBoZWlnaHQ9IjIxMyIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDgxIDEwNCkiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K',\n      id: 'xyz.ithaca.porto',\n      async isAuthorized() {\n        try {\n          // Use retry strategy as some injected wallets (e.g. MetaMask) fail to\n          // immediately resolve JSON-RPC requests on page load.\n          const accounts = await withRetry(() => this.getAccounts())\n          return !!accounts.length\n        } catch {\n          return false\n        }\n      },\n      name: 'Porto',\n      async onAccountsChanged(accounts) {\n        wagmiConfig.emitter.emit('change', {\n          accounts: accounts as readonly Address[],\n        })\n      },\n      onChainChanged(chain) {\n        const chainId = Number(chain)\n        wagmiConfig.emitter.emit('change', { chainId })\n      },\n      async onConnect(connectInfo) {\n        const accounts = await this.getAccounts()\n        if (accounts.length === 0) return\n\n        const chainId = Number(connectInfo.chainId)\n        wagmiConfig.emitter.emit('connect', { accounts, chainId })\n\n        // Manage EIP-1193 event listeners\n        const provider = await this.getProvider()\n        if (provider) {\n          if (connect) {\n            provider.removeListener('connect', connect)\n            connect = undefined\n          }\n          if (!accountsChanged) {\n            accountsChanged = this.onAccountsChanged.bind(this)\n            // Porto Provider uses Ox, which uses `readonly Address.Address[]` for `accountsChanged`,\n            // while Connector `accountsChanged` is `string[]`\n            provider.on('accountsChanged', accountsChanged as never)\n          }\n          if (!chainChanged) {\n            chainChanged = this.onChainChanged.bind(this)\n            provider.on('chainChanged', chainChanged)\n          }\n          if (!disconnect) {\n            disconnect = this.onDisconnect.bind(this)\n            provider.on('disconnect', disconnect)\n          }\n        }\n      },\n      async onDisconnect(_error) {\n        const provider = await this.getProvider()\n\n        wagmiConfig.emitter.emit('disconnect')\n\n        // Manage EIP-1193 event listeners\n        if (provider) {\n          if (chainChanged) {\n            provider.removeListener('chainChanged', chainChanged)\n            chainChanged = undefined\n          }\n          if (disconnect) {\n            provider.removeListener('disconnect', disconnect)\n            disconnect = undefined\n          }\n          if (!connect) {\n            connect = this.onConnect.bind(this)\n            provider.on('connect', connect)\n          }\n        }\n      },\n      async setup() {\n        if (!connect) {\n          const provider = await this.getProvider()\n          connect = this.onConnect.bind(this)\n          provider.on('connect', connect)\n        }\n      },\n      async switchChain({ chainId }) {\n        const chain = chains.find((x) => x.id === chainId)\n        if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n        const provider = await this.getProvider()\n        await provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{ chainId: numberToHex(chainId) }],\n        })\n\n        return chain\n      },\n      type: 'injected',\n    }\n  })\n}\n", "export {\n  useAddFunds,\n  useAdmins,\n  useAssets,\n  useConnect,\n  useDisconnect,\n  useGrantAdmin,\n  useGrantPermissions,\n  usePermissions,\n  useRevokeAdmin,\n  useRevokePermissions,\n  useUpgradeAccount,\n  useVerifyEmail,\n} from './internal/react.js'\n", "'use client'\n\nimport {\n  skipToken,\n  type UseMutationResult,\n  useMutation,\n  useQuery,\n  useQueryClient,\n} from '@tanstack/react-query'\nimport { useEffect, useMemo, useRef } from 'react'\nimport type { EIP1193Provider } from 'viem'\nimport {\n  type Config,\n  type ResolvedRegister,\n  useAccount,\n  useChainId,\n  useConfig,\n} from 'wagmi'\nimport type {\n  UseMutationParameters,\n  UseQueryParameters,\n  UseQueryReturnType,\n} from 'wagmi/query'\n\nimport {\n  addFunds,\n  connect,\n  disconnect,\n  getAdmins,\n  getAssets,\n  getPermissions,\n  grantAdmin,\n  grantPermissions,\n  revokeAdmin,\n  revokePermissions,\n  upgradeAccount,\n  verifyEmail,\n} from './core.js'\nimport {\n  getAdminsQueryKey,\n  getAssetsQueryKey,\n  getPermissionsQueryKey,\n} from './query.js'\nimport type { ConfigParameter } from './types.js'\n\nexport function useAddFunds<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useAddFunds.Parameters<config, context> = {},\n): useAddFunds.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return addFunds(config, variables)\n    },\n    mutationKey: ['addFunds'],\n  })\n}\n\nexport declare namespace useAddFunds {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> &\n    addFunds.Parameters<config> &\n    ConfigParameter<config> & {\n      mutation?:\n        | UseMutationParameters<\n            addFunds.ReturnType,\n            addFunds.ErrorType,\n            addFunds.Parameters<config>,\n            context\n          >\n        | undefined\n    }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    addFunds.ReturnType,\n    addFunds.ErrorType,\n    addFunds.Parameters<config>,\n    context\n  >\n}\n\nexport function useAdmins<\n  config extends Config = ResolvedRegister['config'],\n  selectData = getAdmins.ReturnType,\n>(\n  parameters: useAdmins.Parameters<config, selectData> = {},\n): useAdmins.ReturnType<selectData> {\n  const { query = {}, ...rest } = parameters\n\n  const config = useConfig(rest)\n  const queryClient = useQueryClient()\n  const chainId = useChainId({ config })\n  const { address, connector, status } = useAccount()\n  const activeConnector = parameters.connector ?? connector\n\n  const enabled = Boolean(\n    (status === 'connected' ||\n      (status === 'reconnecting' && activeConnector?.getProvider)) &&\n      (query.enabled ?? true),\n  )\n  const queryKey = useMemo(\n    () =>\n      getAdminsQueryKey({\n        address,\n        chainId: parameters.chainId ?? chainId,\n        connector: activeConnector,\n      }),\n    [address, chainId, parameters.chainId, activeConnector],\n  )\n\n  const provider = useRef<EIP1193Provider | undefined>(undefined)\n  // biome-ignore lint/correctness/useExhaustiveDependencies: `queryKey` not required\n  useEffect(() => {\n    if (!activeConnector) return\n    void (async () => {\n      provider.current ??=\n        (await activeConnector.getProvider?.()) as EIP1193Provider\n      provider.current?.on('message', (event) => {\n        if (event.type !== 'adminsChanged') return\n        queryClient.invalidateQueries({ queryKey })\n      })\n    })()\n  }, [address, activeConnector, queryClient])\n\n  return useQuery({\n    ...(query as any),\n    enabled,\n    gcTime: 0,\n    queryFn: activeConnector\n      ? async (context) => {\n          const { connectorUid: _, ...options } = (\n            context.queryKey as typeof queryKey\n          )[1]\n          provider.current ??=\n            (await activeConnector.getProvider()) as EIP1193Provider\n          return await getAdmins(config, {\n            ...options,\n            connector: activeConnector,\n          })\n        }\n      : skipToken,\n    queryKey,\n    staleTime: Number.POSITIVE_INFINITY,\n  }) as never\n}\n\nexport declare namespace useAdmins {\n  type Parameters<\n    config extends Config = Config,\n    selectData = getAdmins.ReturnType,\n  > = getAdmins.Parameters<config> &\n    ConfigParameter<config> & {\n      query?:\n        | Omit<\n            UseQueryParameters<\n              getAdmins.ReturnType,\n              getAdmins.ErrorType,\n              selectData,\n              getAdminsQueryKey.Value<config>\n            >,\n            'gcTime' | 'staleTime'\n          >\n        | undefined\n    }\n\n  type ReturnType<selectData = getAdmins.ReturnType> = UseQueryReturnType<\n    selectData,\n    getAdmins.ErrorType\n  >\n}\n\nexport function useAssets<\n  config extends Config = ResolvedRegister['config'],\n  selectData = getAssets.ReturnType,\n>(\n  parameters: useAssets.Parameters<config, selectData> = {},\n): useAssets.ReturnType<selectData> {\n  const {\n    assetFilter,\n    assetTypeFilter,\n    chainFilter,\n    query = {},\n    ...rest\n  } = parameters\n\n  const config = useConfig(rest)\n  const queryClient = useQueryClient()\n  const { address, connector, status } = useAccount()\n\n  const account = parameters.account ?? address\n  const activeConnector = parameters.connector ?? connector\n\n  const enabled = Boolean(\n    account &&\n      (status === 'connected' ||\n        (status === 'reconnecting' && activeConnector?.getProvider)) &&\n      (query.enabled ?? true),\n  )\n\n  const queryKey = useMemo(\n    () =>\n      getAssetsQueryKey({\n        account,\n        assetFilter,\n        assetTypeFilter,\n        chainFilter,\n        connector: activeConnector,\n      }),\n    [account, activeConnector, assetFilter, assetTypeFilter, chainFilter],\n  )\n\n  const provider = useRef<EIP1193Provider | undefined>(undefined)\n  // biome-ignore lint/correctness/useExhaustiveDependencies: `queryKey` not required\n  useEffect(() => {\n    if (!activeConnector) return\n    void (async () => {\n      provider.current ??=\n        (await activeConnector.getProvider?.()) as EIP1193Provider\n      provider.current?.on('message', (event) => {\n        if (event.type !== 'assetsChanged') return\n        queryClient.invalidateQueries({ queryKey })\n      })\n    })()\n  }, [address, activeConnector, queryClient])\n\n  return useQuery({\n    ...(query as any),\n    enabled,\n    gcTime: 0,\n    queryFn: activeConnector\n      ? async (context) => {\n          const { connectorUid: _, ...options } = (\n            context.queryKey as typeof queryKey\n          )[1]\n          provider.current ??=\n            (await activeConnector.getProvider()) as EIP1193Provider\n          return await getAssets(config, {\n            ...options,\n            connector: activeConnector,\n          })\n        }\n      : skipToken,\n    queryKey,\n    staleTime: Number.POSITIVE_INFINITY,\n  }) as never\n}\n\nexport declare namespace useAssets {\n  type Parameters<\n    config extends Config = Config,\n    selectData = getAssets.ReturnType,\n  > = getAssets.Parameters &\n    ConfigParameter<config> & {\n      query?:\n        | Omit<\n            UseQueryParameters<\n              getAssets.ReturnType,\n              getAssets.ErrorType,\n              selectData,\n              getAssetsQueryKey.Value<config>\n            >,\n            'gcTime' | 'staleTime'\n          >\n        | undefined\n    }\n\n  type ReturnType<selectData = getAssets.ReturnType> = UseQueryReturnType<\n    selectData,\n    getAssets.ErrorType\n  >\n}\n\nexport function useConnect<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useConnect.Parameters<config, context> = {},\n): useConnect.ReturnType<context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return connect(config as Config, variables)\n    },\n    mutationKey: ['connect'],\n  })\n}\n\nexport declare namespace useConnect {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          connect.ReturnType,\n          connect.ErrorType,\n          connect.Parameters,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<context = unknown> = UseMutationResult<\n    connect.ReturnType,\n    connect.ErrorType,\n    connect.Parameters,\n    context\n  >\n}\n\nexport function useDisconnect<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useDisconnect.Parameters<context> = {},\n): useDisconnect.ReturnType<context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      await disconnect(config, variables)\n    },\n    mutationKey: ['disconnect'],\n  })\n}\n\nexport declare namespace useDisconnect {\n  type Parameters<context = unknown> = ConfigParameter & {\n    mutation?:\n      | UseMutationParameters<\n          disconnect.ReturnType,\n          disconnect.ErrorType,\n          disconnect.Parameters,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<context = unknown> = UseMutationResult<\n    disconnect.ReturnType,\n    disconnect.ErrorType,\n    disconnect.Parameters,\n    context\n  >\n}\n\nexport function useGrantAdmin<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useGrantAdmin.Parameters<config, context> = {},\n): useGrantAdmin.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return grantAdmin(config, variables)\n    },\n    mutationKey: ['grantAdmin'],\n  })\n}\n\nexport declare namespace useGrantAdmin {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          grantAdmin.ReturnType,\n          grantAdmin.ErrorType,\n          grantAdmin.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    grantAdmin.ReturnType,\n    grantAdmin.ErrorType,\n    grantAdmin.Parameters<config>,\n    context\n  >\n}\n\nexport function useGrantPermissions<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useGrantPermissions.Parameters<config, context> = {},\n): useGrantPermissions.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return grantPermissions(config, variables)\n    },\n    mutationKey: ['grantPermissions'],\n  })\n}\n\nexport declare namespace useGrantPermissions {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          grantPermissions.ReturnType,\n          grantPermissions.ErrorType,\n          grantPermissions.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    grantPermissions.ReturnType,\n    grantPermissions.ErrorType,\n    grantPermissions.Parameters<config>,\n    context\n  >\n}\n\nexport function usePermissions<\n  config extends Config = ResolvedRegister['config'],\n  selectData = getPermissions.ReturnType,\n>(\n  parameters: usePermissions.Parameters<config, selectData> = {},\n): usePermissions.ReturnType<selectData> {\n  const { query = {}, ...rest } = parameters\n\n  const config = useConfig(rest)\n  const queryClient = useQueryClient()\n  const chainId = useChainId({ config })\n  const { address, connector, status } = useAccount()\n  const activeConnector = parameters.connector ?? connector\n\n  const enabled = Boolean(\n    (status === 'connected' ||\n      (status === 'reconnecting' && activeConnector?.getProvider)) &&\n      (query.enabled ?? true),\n  )\n  const queryKey = useMemo(\n    () =>\n      getPermissionsQueryKey({\n        address,\n        chainId: parameters.chainId ?? chainId,\n        connector: activeConnector,\n      }),\n    [address, chainId, parameters.chainId, activeConnector],\n  )\n\n  const provider = useRef<EIP1193Provider | undefined>(undefined)\n  // biome-ignore lint/correctness/useExhaustiveDependencies: `queryKey` not required\n  useEffect(() => {\n    if (!activeConnector) return\n    void (async () => {\n      provider.current ??=\n        (await activeConnector.getProvider?.()) as EIP1193Provider\n      provider.current?.on('message', (event) => {\n        if (event.type !== 'permissionsChanged') return\n        queryClient.invalidateQueries({ queryKey })\n      })\n    })()\n  }, [address, activeConnector, queryClient])\n\n  return useQuery({\n    ...(query as any),\n    enabled,\n    gcTime: 0,\n    queryFn: activeConnector\n      ? async (context) => {\n          const { connectorUid: _, ...options } = (\n            context.queryKey as typeof queryKey\n          )[1]\n          provider.current ??=\n            (await activeConnector.getProvider()) as EIP1193Provider\n          return await getPermissions(config, {\n            ...options,\n            connector: activeConnector,\n          })\n        }\n      : skipToken,\n    queryKey,\n    staleTime: Number.POSITIVE_INFINITY,\n  }) as never\n}\n\nexport declare namespace usePermissions {\n  type Parameters<\n    config extends Config = Config,\n    selectData = getPermissions.ReturnType,\n  > = getPermissions.Parameters<config> &\n    ConfigParameter<config> & {\n      query?:\n        | Omit<\n            UseQueryParameters<\n              getPermissions.ReturnType,\n              getPermissions.ErrorType,\n              selectData,\n              getPermissionsQueryKey.Value<config>\n            >,\n            'gcTime' | 'staleTime'\n          >\n        | undefined\n    }\n\n  type ReturnType<selectData = getPermissions.ReturnType> = UseQueryReturnType<\n    selectData,\n    getPermissions.ErrorType\n  >\n}\n\nexport function useRevokeAdmin<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useRevokeAdmin.Parameters<config, context> = {},\n): useRevokeAdmin.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return revokeAdmin(config, variables)\n    },\n    mutationKey: ['revokeAdmin'],\n  })\n}\n\nexport declare namespace useRevokeAdmin {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          undefined,\n          revokeAdmin.ErrorType,\n          revokeAdmin.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    undefined,\n    revokeAdmin.ErrorType,\n    revokeAdmin.Parameters<config>,\n    context\n  >\n}\n\nexport function useRevokePermissions<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useRevokePermissions.Parameters<config, context> = {},\n): useRevokePermissions.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return revokePermissions(config, variables)\n    },\n    mutationKey: ['revokePermissions'],\n  })\n}\n\nexport declare namespace useRevokePermissions {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          undefined,\n          revokePermissions.ErrorType,\n          revokePermissions.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    undefined,\n    revokePermissions.ErrorType,\n    revokePermissions.Parameters<config>,\n    context\n  >\n}\n\nexport function useUpgradeAccount<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useUpgradeAccount.Parameters<config, context> = {},\n): useUpgradeAccount.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return upgradeAccount(config as Config, variables)\n    },\n    mutationKey: ['upgradeAccount'],\n  })\n}\n\nexport declare namespace useUpgradeAccount {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          upgradeAccount.ReturnType,\n          upgradeAccount.ErrorType,\n          upgradeAccount.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    upgradeAccount.ReturnType,\n    upgradeAccount.ErrorType,\n    upgradeAccount.Parameters<config>,\n    context\n  >\n}\n\nexport function useVerifyEmail<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useVerifyEmail.Parameters<config, context> = {},\n): useVerifyEmail.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return verifyEmail(config as Config, variables)\n    },\n    mutationKey: ['verifyEmail'],\n  })\n}\n\nexport declare namespace useVerifyEmail {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          verifyEmail.ReturnType,\n          verifyEmail.ErrorType,\n          verifyEmail.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    verifyEmail.ReturnType,\n    verifyEmail.ErrorType,\n    verifyEmail.Parameters<config>,\n    context\n  >\n}\n", "// TODO: Export from wagmi internals\nexport function filterQueryOptions<type extends Record<string, unknown>>(\n  options: type,\n): type {\n  // destructuring is super fast\n  // biome-ignore format: no formatting\n  const {\n    // import('@tanstack/query-core').QueryOptions\n    _defaulted, behavior, gcTime, initialData, initialDataUpdatedAt, maxPages, meta, networkMode, queryFn, queryHash, queryKey, queryKeyHashFn, retry, retryDelay, structuralSharing,\n\n    // import('@tanstack/query-core').InfiniteQueryObserverOptions\n    getPreviousPageParam, getNextPageParam, initialPageParam,\n\n    // import('@tanstack/react-query').UseQueryOptions\n    _optimisticResults, enabled, notifyOnChangeProps, placeholderData, refetchInterval, refetchIntervalInBackground, refetchOnMount, refetchOnReconnect, refetchOnWindowFocus, retryOnMount, select, staleTime, suspense, throwOnError,\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // wagmi\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    config, connector, query,\n    ...rest\n  } = options\n\n  return rest as type\n}\n", "import type { Config } from '@wagmi/core'\n\nimport type { getAdmins, getAssets, getPermissions } from './core.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport function getAdminsQueryKey<config extends Config>(\n  options: getAdmins.Parameters<config> = {},\n) {\n  const { connector, ...parameters } = options\n  return [\n    'admins',\n    { ...filterQueryOptions(parameters), connectorUid: connector?.uid },\n  ] as const\n}\n\nexport declare namespace getAdminsQueryKey {\n  type Value<config extends Config> = ReturnType<\n    typeof getAdminsQueryKey<config>\n  >\n}\n\nexport function getPermissionsQueryKey<config extends Config>(\n  options: getPermissions.Parameters<config> = {},\n) {\n  const { connector, ...parameters } = options\n  return [\n    'permissions',\n    { ...filterQueryOptions(parameters), connectorUid: connector?.uid },\n  ] as const\n}\n\nexport declare namespace getPermissionsQueryKey {\n  type Value<config extends Config> = ReturnType<\n    typeof getPermissionsQueryKey<config>\n  >\n}\n\nexport function getAssetsQueryKey<config extends Config>(\n  options: getAssets.Parameters,\n) {\n  const { connector, ...parameters } = options\n  return [\n    'assets',\n    { ...filterQueryOptions(parameters), connectorUid: connector?.uid },\n  ] as const\n}\n\nexport declare namespace getAssetsQueryKey {\n  type Value<config extends Config> = ReturnType<\n    typeof getAssetsQueryKey<config>\n  >\n}\n", "export {\n  getAdminsQueryKey,\n  getAssetsQueryKey,\n  getPermissionsQueryKey,\n} from './internal/query.js'\n"],
  "mappings": "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",
  "names": ["addFunds", "connect", "disconnect", "getAdmins", "getAssets", "getPermissions", "grantAdmin", "grantPermissions", "revokeAdmin", "revokePermissions", "upgradeAccount", "value", "connect", "disconnect", "connect", "disconnect", "addFunds", "getAdmins", "getAssets", "getPermissions", "grantAdmin", "grantPermissions", "revokeAdmin", "revokePermissions", "upgradeAccount", "verifyEmail", "connect", "disconnect", "addFunds", "getAdmins", "getAssets", "connect", "disconnect", "grantAdmin", "grantPermissions", "getPermissions", "revokeAdmin", "revokePermissions", "upgradeAccount", "verifyEmail"]
}
